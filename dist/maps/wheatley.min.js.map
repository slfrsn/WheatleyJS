{"version":3,"names":[],"mappings":"","sources":["wheatley.min.js"],"sourcesContent":["/*!\n * CSS Portals, v1.0a (http://github.com/scfrsn)\n * Copyright 2016 Stef Friesen (http://frsn.ca)\n * Licensed under the MIT license\n * Last Updated: 1/22/2016, 4:30:33 PM\n */\n\n(function($) {\n    $.wheatley = function(element, options) {\n      var plugin = this,\n        $element = $(element),\n            $gun = $('<div id=\"portal-gun\"></div>'),\n       $document = $(document),\n           $body = $('body'),\n    animationEnd = 'webkitAnimationEnd mozAnimationEnd MSAnimationEnd oanimationend animationend';\n\n      var defaults = {\n        size      : 200,\n        animation : true,\n        quality   : 'high',\n        container : 'body'\n      };\n\n      plugin.settings = $.extend({}, defaults, options);\n\n      plugin.initialize = function() {\n        plugin.gun.initialize();\n        // Left click in the element to create a blue portal, right click for orange\n        $element.on('click contextmenu', function(e) {\n          if(e.type == 'click')       plugin.portal.create('blue',   { x : e.pageX, y : e.pageY });\n          if(e.type == 'contextmenu') plugin.portal.create('orange', { x : e.pageX, y : e.pageY });\n          return false;\n        });\n        // Left click on an existing portal to destroy, right click to destroy orange\n        $document.on('click contextmenu', '.portal div', function(e) {\n          var eventTarget = $(e.target).parent().attr('id').replace('-portal',''),\n                   target = e.type == 'click' ? 'blue' : 'orange';\n          if(eventTarget == target) {\n            plugin.portal.destroy(target);\n            plugin.gun.animate('fire');\n          } else {\n            plugin.gun.animate('misfire');\n          }\n          return false;\n        });\n      }\n\n// /////////////////////// DRAG AND DROP TESTING\n//\n//       plugin.dragReady = function(boolean) {\n//         \tvar dropZoneOne = $('.portal');\n//         \tvar dragElements = $('#companion-cube');\n//         \tvar elementDragged = null;\n//\n//             // if(boolean === true) {\n//           \t// \t// Event Listener for when the drag interaction starts.\n//           \t// \tdragElements.on('dragstart', function(e) {\n//           \t// \t\te.originalEvent.dataTransfer.effectAllowed = 'move';\n//           \t// \t\telementDragged = this;\n//           \t// \t});\n//           \t// \t// Event Listener for when the drag interaction finishes.\n//           \t// \tdragElements.on('dragend', function(e) { elementDragged = null; });\n//             // } else {\n//             //   dragElements.off('dragstart');\n//             //\n//             // }\n//\n//           // if(boolean === true) {\n//             dropZoneOne.bind({\n//               dragenter: function(e) {\n//                 e.stopPropagation(); e.preventDefault();\n//               },\n//               dragleave: function(e) {\n//                 e.stopPropagation(); e.preventDefault();\n//                 $(this).removeClass('drop');\n//               },\n//               dragover: function(e) {\n//                 e.stopPropagation(); e.preventDefault();\n//                 $(this).addClass('drop');\n//               },\n//               drop: function(e) {\n//                 e.stopPropagation(); e.preventDefault();\n//                 dragElements.remove();\n//               }\n//             });\n//\n//             dragElements.bind({\n//               dragstart: function(e) {\n//                 e.originalEvent.effectAllowed = \"copy\";\n//                 $(this).addClass('dragged');\n//                 var img = $('<img src=\"' + $(this).attr('src') + '\"/>').css({ width : 200 });\n//                 e.originalEvent.dataTransfer.setDragImage(img, 0, 0);\n//               }\n//             });\n//\n//             // }\n//\n// /////////////////////// END DRAG AND DROP TESTING\n\n      plugin.option = function(key, value) {\n        if (value !== undefined) {\n          plugin.settings[key] = value;\n        } else {\n          return plugin.settings[key];\n        }\n      }\n\n      // Calculates the bounding box of all of the plugin elements\n      plugin.locate = function() {\n          return new function() {\n            var portal = function(colour) {\n              var $portal = $('#' + colour + '-portal');\n              if($portal.length) {\n                return {\n                  top    : $portal.offset().top,\n                  left   : $portal.offset().left,\n                  bottom : $portal.offset().top + plugin.settings.size * 1.3,\n                  right  : $portal.offset().left + plugin.settings.size,\n                };\n              }\n              return null;\n            }\n            this.blue   = portal('blue');\n            this.orange = portal('orange');\n            this.parent = {\n              top    : $element.offset().top,\n              left   : $element.offset().left,\n              bottom : $element.offset().top + $element.outerHeight(),\n              right  : $element.offset().left + $element.outerWidth()\n            };\n            this.gun = {\n              top:  $gun.offset().top  - ($gun.outerWidth() / 4),\n              left: $gun.offset().left - ($gun.outerWidth() / 4)\n            };\n          }\n      }\n\n      plugin.destroy = function(callback) {\n        plugin.gun.destroy();\n        plugin.portal.destroy('blue');\n        plugin.portal.destroy('orange');\n        $element.off('click contextmenu');\n        $document.off('click contextmenu', '.portal div');\n        $element.removeData();\n        if (callback && (typeof callback == \"function\")) callback();\n      }\n\n      plugin.portal = {\n        create: function(colour, coordinates, callback) {\n            // The coordinates and callback arguments are both optional\n            // Make the sure the proper argument is being passed if others are missing\n            if (arguments.length == 1) {\n              coordinates = { x : 0, y : 0 };\n              callback = function() {};\n            } else if (arguments.length == 2) {\n              callback = function() {};\n              if (typeof coordinates == 'function') callback = coordinates;\n            }\n            var x = coordinates.x,\n                y = coordinates.y;\n            var animation = plugin.settings.animation == true ? 'spin' : '',\n                  quality = plugin.settings.quality == 'high' ? 'high-quality' : '',\n                 template = '<div id=\"' + colour + '-portal\" class=\"portal appear ' + animation + ' ' + quality + '\">' +\n                              '<div class=\"darkest\"></div>' +\n                              '<div class=\"darker\"></div>' +\n                              '<div class=\"normal\"></div>' +\n                              '<div class=\"lighter\"></div>' +\n                              '<div class=\"lightest\"></div>' +\n                              '<div class=\"entrance\"></div>' +\n                            '</div>';\n            // Prevent the portals from spilling over the edges of the element\n            var newPortal = plugin.portal.calculate(x, y);\n            var container = plugin.locate().parent;\n            if (newPortal.left   < container.left  ) x = container.left   + newPortal.center.x;\n            if (newPortal.top    < container.top   ) y = container.top    + newPortal.center.y;\n            if (newPortal.right  > container.right ) x = container.right  - newPortal.center.x;\n            if (newPortal.bottom > container.bottom) y = container.bottom - newPortal.center.y;\n            // Prepare the updated coordinates and dimensions to apply to the new portal\n            var portalProperties = {\n              width  : plugin.settings.size + 'px',\n              height : plugin.settings.size + 'px',\n              top    : y - (plugin.settings.size / 2),\n              left   : x - (plugin.settings.size / 2)\n            }\n            // Recalculate the portal bounds after compensating for spillage\n            newPortal = plugin.portal.calculate(x, y)\n            // Check if the new portal will overlap the portal of the opposite colour\n            var altPortal = (colour == 'orange') ? plugin.locate().blue : plugin.locate().orange;\n            if (altPortal && newPortal.right > altPortal.left && newPortal.left < altPortal.right && newPortal.top < altPortal.bottom && newPortal.bottom > altPortal.top) {\n              plugin.gun.animate('misfire');\n            } else {\n              // If the portal already exists, move it\n        \t    $('#' + colour + '-portal').remove();\n        \t    $(template).appendTo('body').css(portalProperties);\n              $gun.addClass(colour);\n        \t\t  plugin.gun.animate('fire');\n            }\n            if (callback && (typeof callback == \"function\")) callback();\n        },\n        // Calculates what the bounding box, center position, and dimensions of a\n        // portal at a given position.\n        calculate: function(x, y) {\n            this.center = {\n              y : plugin.settings.size * 1.3 / 2, // Multiplier accounts for the scaleY() transform\n              x : plugin.settings.size / 2\n            };\n            this.top    = y - this.center.y;\n            this.left   = x - this.center.x;\n            this.bottom = y + this.center.y;\n            this.right  = x + this.center.x;\n            return this;\n        },\n        destroy: function(colour, callback) {\n        \t\t$('#' + colour + '-portal').addClass('disappear').one(animationEnd, function() { $(this).remove(); });\n            $gun.removeClass(colour);\n            if (callback && (typeof callback == \"function\")) callback();\n        }\n      }\n\n      plugin.gun = {\n        initialize: function(callback) {\n            // Only allow one instance of the portal gun\n            if ($gun.length) plugin.gun.destroy();\n            // Place the portal gun at the top of the container\n            var y = plugin.locate().parent.top,\n                x = plugin.locate().parent.left;\n            // Attach the portal gun to the DOM\n        \t\t$gun.appendTo('body').css({ top : y, left : x });\n          \t// Map the portal gun to the cursor\n          \t$document.on('mousemove', plugin.settings.container + ', .portal div', function(e) {\n        \t\t\t$body.addClass('portal-gun-active');\n              plugin.gun.update(e.pageX, e.pageY);\n          \t}).on('mouseout', plugin.settings.container, function(){\n              $body.removeClass('portal-gun-active');\n            });\n            if (callback && (typeof callback == \"function\")) callback();\n        },\n        // Position the portal gun over the cursor, accounting for the proper offset\n        update: function(x, y) {\n            $gun.css({\n              top:  y - ($gun.outerWidth() / 1.6),\n              left: x - ($gun.outerWidth() / 2)\n            });\n        },\n        // Accepts any CSS animation class (e.g. 'fire', 'misfire' or custom)\n        animate: function(animation, callback) {\n        \t\t// $gun.addClass(animation).one(animationEnd, function() { $(this).removeClass(animation); });\n            if (callback && (typeof callback == \"function\")) callback();\n        },\n        destroy: function(callback) {\n            $document.off('mousemove', plugin.settings.container + ', .portal div').off('mouseout', plugin.settings.container);\n            $body.removeClass('portal-gun-active');\n            $gun.remove();\n            if (callback && (typeof callback == \"function\")) callback();\n        }\n      }\n      plugin.initialize();\n    }\n    $.fn.wheatley = function(options) {\n      return this.each(function() {\n        if (undefined == $(this).data('wheatley')) {\n          var plugin = new $.wheatley(this, options);\n          $(this).data('wheatley', plugin);\n        }\n      });\n    }\n})(jQuery);\n"],"file":"wheatley.min.js","sourceRoot":"/source/"}